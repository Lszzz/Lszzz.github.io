<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java的重写与重载</title>
      <link href="/2020/03/10/java%E7%9A%84%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/"/>
      <url>/2020/03/10/java%E7%9A%84%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h1><p>在java的继承一章，学到了重写这一定义，与重载有很多相似点，因而将他们之间进行对比来看。  </p><p>网上的博客模糊不清，对于子类中的重载和重写方面写的较为模糊，下面是我通过实验自己总结的几点，虽不知正确与否，望有缘人指正。  </p><h2 id="重写定义："><a href="#重写定义：" class="headerlink" title="重写定义："></a>重写定义：</h2><ul><li><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p></li><li><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p></li><li><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。</p></li></ul><h2 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h2><ul><li><p>参数列表必须完全与被重写方法的相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。  </p></li><li><p>如果不能继承一个方法，则不能重写这个方法。</p></li></ul><p>在Java核心技术卷中写道：<br>编译器查看对象上应用方法的调用非常重要。下面假设要调用x.f(args)。  </p><ol><li>编译器查看对象的声明类型和方法名。假设调用时存在多个方法f，但参数类型不同。编译器会将c类中名为的方法，以及c类超类中的访问属性为public且名为f的方法列举出来。  </li><li>接下来，编译器会查看调用方法时提供的参数类型。如果在所有名叫f的方法中存在一个与提供的参数类型完全匹配的方法则调用此种方法。</li></ol><p>因而区别子类中的重载和重写，参数得类型数量是区别的关键。  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> d;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a=a;</span><br><span class="line">            <span class="keyword">this</span>.b=b;</span><br><span class="line">            <span class="keyword">this</span>.c=c;</span><br><span class="line">            <span class="keyword">this</span>.d=d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">short</span> a,<span class="keyword">short</span> b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> sum(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>此为超类A的代码。  </p><p>对于子类B的代码我们来一个一个分析。<br>首先构造方法不能重写，子类不能继承父类的构造方法,但可以调用。因而在子类中的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d,<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(a, b, c, d);</span><br><span class="line">  <span class="keyword">this</span>.g=g;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     <span class="keyword">this</span>.g=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>注入此类的构造器都是重载而非重写。  </p><p>对于方法重写有如下例子：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//重载</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (a+b+<span class="number">1</span>);<span class="comment">//重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 重写主要在于参数，对于1,3的参数来说都不匹配因而为重载，而对于2来说由于参数匹配因而是重写。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 重载更像一种平行关系，根据参数的类型以及个数的不同来重载。而重写则是一种垂直的关系，对于参数返回值完全相同的方法，通过子类的重新定义，达到换内不换壳的效果。当子类调用统一方法时调用的是子类重新实现的方法，而不再调用超类中的方法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql高级联结</title>
      <link href="/2020/03/09/mysql%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/"/>
      <url>/2020/03/09/mysql%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql高级联结"><a href="#mysql高级联结" class="headerlink" title="mysql高级联结"></a>mysql高级联结</h1><p>SQL最强大的功能就是能在数据查询的时候执行联结表，联结可以让多个相关的表联结成一个整体进行运算查询，因而掌握它十分重要。  </p><h2 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h2><p>顾名思义自联结的意思就是一个表与自己相联结。例如想发送一封信给Jim所在公司的所有客户。因此我们先要查询Jim所在的公司，然后找出为此公司工作的客户。<br>此题有两种解法：子查询以及自联结</p><ul><li><p>1</p><blockquote><p>select cust_id,cust_name,cust_address from customers where cust_name =(select cust_name from customers where cust_contact =’Jim Jones’);  </p></blockquote></li><li><p>2</p></li></ul><blockquote><p>select c1.cust_id,c1.cust_name,c1.cust_address from customers as c1,customers as c2 where c1.cust_name =c2.cust_name and c2.cust_contact=’Jim Jones’  </p></blockquote><h2 id="内联结（等值联结）"><a href="#内联结（等值联结）" class="headerlink" title="内联结（等值联结）"></a>内联结（等值联结）</h2><p>内联结是基于两个表之间的相等测试，这种联结也称为内部联结。它适用于多个表之间存在一定的联系的情况。例如购物者购买了编号为1的商品，购物者位于购物表中，而<br>商品表中恰好也有商品编号，那么就可以将多个表进行联结以便查询。  </p><p>查找订购产品RGAN01的顾客信息:   </p><blockquote><p>select cust_id,cust_name,cust_address from customers where cust_id in (select cust_id from orders where order_num in(select order_num from orderitems where prod_id=’RGAN01’));</p></blockquote><p>  将相关项紧密联结依次查询。  </p><h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中。内联结是联结运算符为“=”时的特例。<br>它是从关系R与S的广义笛卡尔积中选取A，B属性值相等的那些元组，而自然联结又是一种特殊的内联结，它能够自动清除掉在两个表中不同属性的元组。因而自然联结不需要加上最后的on和等于判断。</p><p>内联结：  </p><blockquote><p>select p.*,v.*<br>from productinfo as p inner join vendors as v<br>on p.vendname=v.vendname  </p></blockquote><p><a href="https://s1.ax1x.com/2020/03/13/8KUlp6.png" target="_blank" rel="noopener">alt photo</a></p><p>自然联结：  </p><blockquote><p>select p.*,v.*<br>from productinfo as p natural join vendors as v  </p></blockquote><p><a href="https://s1.ax1x.com/2020/03/13/8KUlp6.png" target="_blank" rel="noopener">alt photo</a></p><p>两者的结果相同，但代码有所不同。  </p><h2 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h2><p>许多联结将一个表中的行与另一个表中的行相关联。但有时又需要哪些没有关联行的行。例如：  </p><ul><li>对每个客户下了多少订单进行技术，同时包括尚未下单的客户。  </li><li>列出所有产品以及订购数量，包括没有人订购的商品。  </li><li>计算平均销售规模，包括那些尚未下单的客户。  </li></ul><p>为了检索所有客户，包括未下单的客户：  </p><blockquote><p>select customers.cust_id,orders.order_num from customers left outer join orders on customers.cust_id=orders.cust_id;</p></blockquote><p>结果比正常的内联结多了一项存在于左表却不存在于右表的元组。<br>以次类推有： right outer join … on …  full outer join … on …;    </p><p>其中mysql、SQL SERVER 等不支持full outer join。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj-3255 次短路</title>
      <link href="/2020/03/09/poj-3255-%E6%AC%A1%E7%9F%AD%E8%B7%AF/"/>
      <url>/2020/03/09/poj-3255-%E6%AC%A1%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="次短路"><a href="#次短路" class="headerlink" title="次短路"></a>次短路</h1><p>poj-3255  </p><p>题目：<br>Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path.</p><p>The countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N.</p><p>The second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path).  </p><p>input:<br>Line 1: Two space-separated integers: N and R<br>Lines 2.. R+1: Each line contains three space-separated integers: A, B, and D that describe a road that connects intersections A and B and has length D (1 ≤ D ≤ 5000)   </p><p>Output:<br>Line 1: The length of the second shortest path between node 1 and node N   </p><p>Sample input:<br>4 4<br>1 2 100<br>2 4 200<br>2 3 250<br>3 4 100  </p><p>Sample output:<br>450   </p><p>题目大意：给出点以及点之间的距离，求出点1和点n之间次短路的距离。  </p><p>分析：此题是次短路的模板题，要求此短路只需用dij或sfa在跑出最短路径之后加上一个判断此段路径的条件有语句即可。开两个数组，一个储存最短路径，一个储存次短路径。注意：对于有的点可能没有次短路径，因而对于没有次短路径的数组元素，在代码中的体现为无穷大,具体实现实现见代码。  </p><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;<span class="keyword">int</span> n,m,u,v,w;<span class="keyword">int</span> dis1[maxn],dis2[maxn];<span class="class"><span class="keyword">struct</span> <span class="title">P</span></span><span class="class">{</span><span class="keyword">int</span> to,cost;<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> P &amp;a) <span class="keyword">const</span>{    <span class="keyword">return</span> cost&gt;a.cost;    }    };<span class="built_in">vector</span>&lt;P&gt; edge[maxn];<span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span><span class="function"></span>{    priority_queue&lt;P&gt; qu;    <span class="built_in">fill</span>(dis1,dis1+n+<span class="number">1</span>,INF);    <span class="built_in">fill</span>(dis2,dis2+n+<span class="number">1</span>,INF);    dis1[<span class="number">1</span>]=<span class="number">0</span>;    qu.push(P{<span class="number">1</span>,<span class="number">0</span>});    <span class="keyword">while</span>(!qu.empty())    {        P x=qu.top();        qu.pop();        <span class="keyword">int</span> v=x.to,d=x.cost;        <span class="keyword">if</span>(d&gt;dis2[v])<span class="comment">//此处判断类似于vis数组的作用，取出来的值如果是比次小值还大那么肯定是已经使用过，或没用的值。</span>        {            <span class="keyword">continue</span>;        }        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].<span class="built_in">size</span>();i++)        {            P y=edge[v][i];            <span class="keyword">int</span> d2=y.cost+d;            <span class="keyword">if</span>(dis1[y.to]&gt;d2)            {                dis1[y.to]=d2;                qu.push(P{y.to,dis1[y.to]});            }            <span class="keyword">if</span>(dis1[y.to]&lt;d2&amp;&amp;dis2[y.to]&gt;d2)<span class="comment">//次短路的值在小于最短路的前提下，使用与求最短路相同的方法进行计算。</span>            {                dis2[y.to]=d2;                qu.push(P{y.to,dis2[y.to]});            }        }    }}<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>{    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)    {        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)        {            edge[i].<span class="built_in">clear</span>();        }        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)        {            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;            edge[u].push_back(P{v,w});            edge[v].push_back(P{u,w});        }        Dijkstra();        <span class="built_in">cout</span>&lt;&lt;dis2[n]&lt;&lt;<span class="built_in">endl</span>;    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 次短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯模拟：字符串</title>
      <link href="/2020/02/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/02/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="计蒜客蓝桥杯模拟：字符串"><a href="#计蒜客蓝桥杯模拟：字符串" class="headerlink" title="计蒜客蓝桥杯模拟：字符串"></a>计蒜客蓝桥杯模拟：字符串</h1><p>题目描述：</p><p>有一个长度为 $L$ 的字符串，每个字符是大写字母。如果我们把 $A$ 看做 $0$ ，$B$ 看做 $1$ ，$C$ 看做 $2$ … $Z$ 看做 $25$，那么我们就得到了一个 $26$ 进制的数字串。  </p><p>我们可以对这个字符串做一个操作：将两个位置的字母进行交换。这样得到了一个新的数字串。  </p><p>现在有一个十进制整数 $M$ ，请判断是否可以通过做至多一次（可以不做）操作，使得得到的字符串是 $M$ 的倍数。</p><p><code>输出格式</code>：  </p><p>第一行一个只包含大写字母的字符串。</p><p>第二行一个整数 $M$.  </p><p><code>输出格式</code>:</p><p>如果初始串就可以，那么输出 “0 0”（不加引号）</p><p>如果通过一次操作可以，请输出交换的两个位置的标号（标号小的在前，从 $1$ 开始）。如果有多解，输出字典序最小的。</p><p>如果做不到，那么输出 “-1 -1”（不加引号）</p><p><code>数据范围</code><br>字符串长度为$L$.<br>对于30%的数据：$1 \le L \ge 10$,$1 \le M \ge 100$  </p><p>对于50%的数据：除前面30%外，$1 \le L \ge 500$,$M = 5$或$25$或$260$  </p><p>对于100%的数据：$1 \le L \ge 2000,1 \le M \ge 200,000$  </p><p>样例输入：  </p><blockquote><p>NETTLE<br>35  </p></blockquote><p>样例输出：  </p><blockquote><p>1 2  </p></blockquote><p>样例解释：<br>交换$N$和第一个$E$。  </p><p>分析：  </p><ul><li><p>此题一看就是模拟题，但要注意数据范围以及运算时间的问题，如果使用pow（）函数的话不仅会超时，而且由于pow返回的是double类型的值会导致运算出错。因此使用一个数组在一开始就存储26的次方结果。同时此题还有一个坑就是字典序指的是标号的字典序而不是字符串的字典序。  </p></li><li><p>在求sum的时候只需将交换的两个值在不同位置的值求出来，将现在的两值之和减去原来的两值之和再加上sum，即为交换后的结果。</p></li><li><p>此题为了防止值超出范围还应活用mod。  </p></li></ul><p>关于mod的运算规则有如下几种：  </p><p>$(a + b)$ % $p=(a $% $p + b $%$ p) $%$ p $<br>$(a - b) $% $p=(a $% $p - b $%$ p) $% $p$<br>$(a \times b)$ % $p=(a $% $p \times b $%$ p) $% $p$<br>$(a \div b)$ % $p=(a $% $p \div b $%$ p) $% $p$  </p><p>为了防止出现负数一般对结果使用：<br>$ans = (ans$ % $\bmod$ $+$ $\bmod)$ %  $\bmod$  </p><p>代码：</p><pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="meta-keyword">define</span> MAX 0x7fffffff</span><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;<span class="keyword">const</span> ll N = <span class="number">2000</span>+<span class="number">10</span>;ll mod, dic[N];<span class="keyword">char</span> ss[N];<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{    <span class="built_in">scanf</span>(<span class="string">"%s%lld"</span>, ss, &amp;mod);    ll len = <span class="built_in">strlen</span>(ss), x = <span class="number">1</span>, sum = <span class="number">0</span>;    <span class="keyword">for</span>(ll i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)        dic[i] = x, sum += x*(ss[i]-<span class="string">'A'</span>), sum %= mod, x = x*<span class="number">26</span>%mod;    <span class="keyword">if</span>(!sum){        <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);        <span class="keyword">return</span> <span class="number">0</span>;    }    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;len; ++i){        <span class="keyword">for</span>(ll j=i+<span class="number">1</span>; j&lt;len; ++j){            ll ans = sum;            ans = ans-dic[i]*(ss[i]-<span class="string">'A'</span>)-dic[j]*(ss[j]-<span class="string">'A'</span>);            ans = ans+dic[i]*(ss[j]-<span class="string">'A'</span>)+dic[j]*(ss[i]-<span class="string">'A'</span>), ans = ans%mod;            <span class="keyword">if</span>(!ans){                <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, i+<span class="number">1</span>, j+<span class="number">1</span>);                <span class="keyword">return</span> <span class="number">0</span>;            }        }    }    <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql命令</title>
      <link href="/2020/02/27/mysql%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/27/mysql%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="登录到本机上的mysql"><a href="#登录到本机上的mysql" class="headerlink" title="登录到本机上的mysql:"></a>登录到本机上的mysql:</h2><blockquote><p>在配置好环境变量的前提下，打开命令行窗口：<br>mysql -h localhost -u root -p<br>随后输入mysql密码。  </p></blockquote><h2 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h2><blockquote><p>create database &lt;数据库名&gt;  </p></blockquote><h2 id="显示数据库："><a href="#显示数据库：" class="headerlink" title="显示数据库："></a>显示数据库：</h2><blockquote><p>show databases;  </p></blockquote><h2 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h2><blockquote><p>drop database &lt;数据库名&gt;  </p></blockquote><h2 id="删除一个不确定是否存在的数据库名："><a href="#删除一个不确定是否存在的数据库名：" class="headerlink" title="删除一个不确定是否存在的数据库名："></a>删除一个不确定是否存在的数据库名：</h2><blockquote><p>drop database if exists tmp  </p></blockquote><p>如果不存在此数据库的话，会返回一个警告显示此数据库不存在。  </p><h2 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h2><blockquote><p>use &lt;数据库名&gt;  </p></blockquote><h2 id="显示当前正在使用的数据库"><a href="#显示当前正在使用的数据库" class="headerlink" title="显示当前正在使用的数据库:"></a>显示当前正在使用的数据库:</h2><blockquote><p>select database();  </p></blockquote><h2 id="创建数据表："><a href="#创建数据表：" class="headerlink" title="创建数据表："></a>创建数据表：</h2><blockquote><p>create table&lt;表名&gt;）(&lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;])  </p></blockquote><h2 id="向数据表中添加数据："><a href="#向数据表中添加数据：" class="headerlink" title="向数据表中添加数据："></a>向数据表中添加数据：</h2><blockquote><p>insert into 表名 values(…..);//insert一次只能插入一条记录。   </p></blockquote><h2 id="查看表中所有数据："><a href="#查看表中所有数据：" class="headerlink" title="查看表中所有数据："></a>查看表中所有数据：</h2><blockquote><p>select *from 表名  </p></blockquote><h2 id="按顺序查找（可按多个列查找）："><a href="#按顺序查找（可按多个列查找）：" class="headerlink" title="按顺序查找（可按多个列查找）："></a>按顺序查找（可按多个列查找）：</h2><blockquote><p>select 列名 from 表名 order by 列名1，列名2  </p></blockquote><h2 id="按降序查找："><a href="#按降序查找：" class="headerlink" title="按降序查找："></a>按降序查找：</h2><blockquote><p>select 列名 from 表名 order by 列名1，列名2  desc;<br>想要按照某一列进行降序则在该列后面加上desc的关键字，desc只对直接位于其之前的列名有作用，如果想在多个列上进行降序排序则需要为每个列执行desc关键词。</p></blockquote><h2 id="查询固定某项的数据："><a href="#查询固定某项的数据：" class="headerlink" title="查询固定某项的数据："></a>查询固定某项的数据：</h2><blockquote><p>select 类型 （as 别名） from 表名  </p></blockquote><p>如果想要使得到的数据去重：  </p><blockquote><p>select distinct 类型 from 表名  </p></blockquote><h2 id="删除表中数据"><a href="#删除表中数据" class="headerlink" title="删除表中数据:"></a>删除表中数据:</h2><blockquote><p>delete from 表名 where 类型名 =…  </p></blockquote><h2 id="想要将某些类型进行拼接输出有如下函数："><a href="#想要将某些类型进行拼接输出有如下函数：" class="headerlink" title="想要将某些类型进行拼接输出有如下函数："></a>想要将某些类型进行拼接输出有如下函数：</h2><blockquote><p>select concat(…,…,…) as …(别名) from emp;  </p></blockquote><h2 id="修改表中数据"><a href="#修改表中数据" class="headerlink" title="修改表中数据:"></a>修改表中数据:</h2><blockquote><p>update 表名 set 字段=新值 where 条件<br>update myclass set name=’we’ where id=1;    </p></blockquote><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="where关键字："><a href="#where关键字：" class="headerlink" title="where关键字："></a>where关键字：</h3><p>where子句操作符：<br>除了常见的=，！=，&lt;=,&gt;=,!&gt;,!&lt;还有between(在指定两值之间)，is null(为null值),&lt;&gt;(不等于)  </p><blockquote><p>between:select price form products where price between 2 and 12;//查找出来的数据的价格处于2~12之间。  </p></blockquote><blockquote><p>is null: select name from products where name is null;//查找名称列为空的数据。    </p></blockquote><h2 id="高级数据过滤"><a href="#高级数据过滤" class="headerlink" title="高级数据过滤"></a>高级数据过滤</h2><h3 id="组合where子句"><a href="#组合where子句" class="headerlink" title="组合where子句"></a>组合where子句</h3><p>AND操作符：<br>为了通过不止一个列进行过滤，可使用AND操作符给where子句附加条件。  </p><blockquote><p>select prod_id,prod_price,prod_name from products where vend_id=’DLL01’ AND prod_price&lt;=4;  </p></blockquote><p>OR操作符：<br>类似于and表示几个条件满足其一。<br>当or与and合用时要注意and的优先级大于or，因而妥善的利用（）至关重要。  </p><p>in操作符：<br>IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全部括在括号内。   </p><blockquote><p>select prod_name, prod_price from products where vend_id IN (‘DLL01’,’BRS01’) ;  </p></blockquote><p>not操作符：<br>not操作符等同于&lt;&gt;，它的作用只有一个那就事否定其后的语句。  </p><blockquote><p>select prod_name from products where not vend_id =’DLL01’ order by prod_name;  </p></blockquote><h2 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h2><p>之前介绍的过滤方法都是已知取值范围或具体数值的，为了适用更普遍的情况，因而引入了通配符。通配符：用来匹配值的一部分的特殊字符。此外通配符只能用于文本字段，非文本数据类型字段则不能使用通配符搜索。  </p><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><h3 id="通配符"><a href="#通配符" class="headerlink" title="%通配符"></a>%通配符</h3><p>搜索串中，%表示任何字符出现任意次数。为了寻找以Fish起头的产品可以使用如下语句：  </p><blockquote><p>select prod_id,prod_name from products where prod_name like ‘Fish%’;</p></blockquote><p>通配符还可以放在搜索模式的中间，可以用来寻找以一个字母为开头以另外一个字母为结尾的结果。  </p><blockquote><p>select prod_name From products where prod_name like ‘F%y’;//搜寻以F开头以y结尾的结果。  </p></blockquote><h3 id="下划线（——）通配符"><a href="#下划线（——）通配符" class="headerlink" title="下划线（——）通配符"></a>下划线（——）通配符</h3><p>下划线与%用途相同，但下划线只匹配单个字符而不是多个字符。  </p><blockquote><p>select prod_id,prod_name,from products where prod_name like ‘_ inch teddy bear’;  </p></blockquote><h3 id="方括号（-）通配符"><a href="#方括号（-）通配符" class="headerlink" title="方括号（[]）通配符"></a>方括号（[]）通配符</h3><p>[]用来指定一个字符集，它必须匹配指定位置的一个字符。<br>例如，找出所有名字以J或M开头的联系人，可如下查询：  </p><blockquote><p>select cust_contact from customer Like ‘[JM]%’ order by cust_contact;  </p></blockquote><p>但并非所有的DBMS都支持这一语句，mysql就不支持，但在access之类的Microsoft系支持。  </p><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>concatenate将值连接到一起构成单个值。<br>一般使用+以及||进行拼接。但在mysql使用函数concat（）；</p><blockquote><p>select concat(vend_name,’(‘,vend_country,vend_country,’)’);  </p></blockquote><h3 id="执行算术运算"><a href="#执行算术运算" class="headerlink" title="执行算术运算"></a>执行算术运算</h3><p>计算字段的另一个常见用途是对检索出来的数据进行计算。如下：  </p><blockquote><p>select prod_id,quantity,item_price,quantity*item_price as expanded_price from orderitems where order_num=20008;  </p></blockquote><h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>大多数sql实现并支持以下类型的函数：  </p><ol><li>处理文本字符串的函数。  </li><li>用于数值操作的数值函数。  </li><li>用于处理日期以及时间的函数。  </li><li>返回DBMS正在使用的特殊信息的函数（如返回用户登录信息）的系统函数。  </li></ol><h3 id="函数带来的问题"><a href="#函数带来的问题" class="headerlink" title="函数带来的问题"></a>函数带来的问题</h3><p>不同于select操作，不同的数据库管理系统有着不同的函数，因而各个函数的实现各不相同，因而在使用时需要多加注意。在本篇博客中主要使用mysql函数。  </p><h3 id="常用的文本处理函数："><a href="#常用的文本处理函数：" class="headerlink" title="常用的文本处理函数："></a>常用的文本处理函数：</h3><p>left()      返回串左边的字符；<br>length()    返回字符串的长度。<br>lower()     将串转化为小写。<br>ltrim()     去掉串左边的空格。<br>right()     返回串右边的字符。<br>rtrim()     去掉右边的空格。<br>soundex()   返回串的soundex值。<br>upper()     将串转化为大写。<br>其中soundex是一个将任何文本串转换为描述其语言表示的字母数字模式的算法。其一般应用于在对于某项数据出现拼写错误，在获悉其正确名称后用soundex来限定读音相近的结果进行搜索。  </p><blockquote><p>select cust_name,cust_contact from customer where soundex(cust_contact)==soundex(‘Michelle Green’));//搜寻读音同MIchelle Green相近的结果。  </p></blockquote><h3 id="日期处理函数"><a href="#日期处理函数" class="headerlink" title="日期处理函数"></a>日期处理函数</h3><p>mysql用户使用year()的函数从日期中提取年份。<br>select order_num from orders where year(order_date)=2004;  </p><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>数值处理函数仅处理数值数据。  </p><p>常用的数值处理函数：<br>ABS()       返回一个数的绝对值<br>COS()       返回一个角度的余弦函数<br>SIN()       返回一个角度的正弦函数<br>EXP()       返回一个数的指数值<br>PI()        返回圆周率<br>SQRT()      返回平方根<br>TAN()       返回一个角度的正切值    </p><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>我们经常需要汇总数据却不一定要将他们检索出来，因而sql提供了专门的函数。例如：</p><ul><li>确定表中的行数。  </li><li>获得表中行组的和。  </li><li>找出表列的最大、最小、平均值。  </li></ul><p>聚集函数：<br>AVG()       返回某列的平均值<br>COUNT()     返回某列的行数<br>MAX()       返回某列最大值<br>MIN()       返回某列最小值<br>SUM()       返回某列之和   </p><p>例子：<br>AVG()  </p><blockquote><p>select AVG(prod_price) AS avg_price From products;  </p></blockquote><p>COUNT()  </p><blockquote><p>select count(*) AS num_cust from Customers;//返回行数。  </p></blockquote><h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><p>以上的5个聚集函数如果想要将他们全部进行运算，指定ALL参数，或者不指定参数（ALL默认）。如果想对无重复值进行运算需要distinct参数。  </p><blockquote><p>select AVG(DISTINCT prod_price) As avg_price FROM products where vend_id=’DLL01’;//只计算不同价格的平均值。  </p></blockquote><h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><p>分组是在select语句的group by子句中建立的。  </p><blockquote><p>select vend_id ,count(*) as num_prods from products group by vend_id;  </p></blockquote><p>by后面的所有列的组合为唯一的。</p><h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><p>除了使用group by 进行分组以外，sql还允许过滤分组，规定包括哪些分组，排除哪些分组。在此引用入了HAVING语句，之前所有的where语句均可以使用HAVING语句进行替换。</p><blockquote><p>select cust_id,count(<em>) AS orders from orders group by cust_id Having<br>Count(</em>) &gt;=2;    </p></blockquote><blockquote><p>select vend_id,count(<em>) as num_prods from products where prod_price&gt;=4 group by vend_id having count(\</em>) &gt;=2;  </p></blockquote><p>Having和where的区别：where在数据分组之前进行过滤，Having在数据进行分组之后进行过滤。Where排除的行不包括在分组之中。</p><h3 id="select子句的顺序"><a href="#select子句的顺序" class="headerlink" title="select子句的顺序"></a>select子句的顺序</h3><ul><li>select  </li><li>from   </li><li>where  </li><li>group by  </li><li>having    </li><li>order by  </li></ul><h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>所谓的子查询即为嵌套在其他查询之中的查询。  </p><h3 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h3><p>子查询的实质即为将多个查询合并为一个查询。子查询总是由内向外进行处理的。  </p><blockquote><p>select cust_id from orders where order_num in(select order_num from orderItems where prod_id=’RGAN01’);    </p></blockquote><p>三个查询嵌套：  </p><blockquote><p>select cust_name,cust_contact from customers where cust_id in(select cust_id from orders where order_num in(select order_num from orderItems where prod_id=’RGAN01’));   </p></blockquote><p>值得注意的是作为子查询的select语句只能查询单个列，企图检索多个列将返回错误。</p><h3 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h3><p>使用子查询的另一方法是创建计算字段。  </p><blockquote><p>select cust_name,cust_state,(select count(*) from orders where orders.cust_id==customer.cust_id) as orders from customers order by cust_name;</p></blockquote><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及他们如何关联即可。  </p><blockquote><p>select vend_name,prod_name,prod_price from vendors,products where vendors.vend_id==products.vend_id;   </p></blockquote><p>此处代码所检索的列与之前的略有不同，vend_name来自于表vendors,而其他的都来自与products表，引入头from语句指向了两个不同的表，并使用where进行了正确的联结。  </p><h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h3><p>目前所涉及到的联结都称为等值联结，它基于两个表之间的相等测试。这种联结也称为内部联结，对于这种联结可以使用稍微不同的语法来指明指定联结的类型。  </p><blockquote><p>select vend_name,prod_name,prod_price from vendors INNER JOIN products on vendors.vend_id=products.vend_id;   </p></blockquote><p>此条代码与上面的代码运行结果相同，仅仅是语法不同，此处两表之间的关系是from子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结的条件用特定的语句on子句而不是WHERE子句。  </p><h3 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h3><p>SQL对一条select语句中可以联结的表的数目没有限制。创建联结的规则也基本相同。首先列出所有的表，然后定义表之间的关系。  </p><blockquote><p>select prod_name,vend_name,prod_price,quantity from orderItems,products,vendors where products.vend_id=vendors.vend_id and orderitems.prods_id=products.prod_ids and order_num=2007;</p></blockquote><h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><p>之前介绍过使用列别名，别名除了用于列名以及计算字段之外，sql还允许给表名起别名。理由主要有两个：  </p><ul><li>缩短sql语句  </li><li>允许在单条select语句中多次使用相同的表。  </li></ul><blockquote><p>select cust_name ,cust_concat from customers AS c,orders As o, orderitems as oi where c.cust_id=o.cust_id and oi.order_nam=O.order_num and  pord_id=’RGAN01’;  </p></blockquote><p>需要注意的是表别名只在查询执行中使用。与列别名不同，表别名不返回到客户机之中。   </p><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>多数sql查询都只包含从一个或多个表中返回数据的单条select语句。但是，sql也允许执行多查询，并将结果作为单个查询结果集返回。这些组合查询通常称为并或复合查询。<br>有两种基本情况，其中需要使用组合查询：  </p><ul><li>在单个查询中从不同的表类返回结构数据。   </li><li>对单个表执行多个查询，按单个查询返回数据。  </li></ul><h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>用UNION操作符来组合数条SQL查询。  </p><p>下面两个例子的结果相同：  </p><blockquote><p>select cust_name,cust_contact from customers where cust_state in(‘IL’,’IN’,’MI’);  </p></blockquote><blockquote><p>select cust_name,cust_contact from customers where cust_name=’Fun4All’;  </p></blockquote><blockquote><p>select cust_name,cust_contact from customers where cust_state in(‘IL’,’IN’,’MI’) UNION<br>select cust_name,cust_contact from customers where cust_name=’Fun4All’;  </p></blockquote><p>当我们使用union后得到的结果会自动去除重复的元组，如果想输出重复的元组只需将union换成union all 即可。<br>另外需要注意的是组合查询中的select语句必须包含相同的列、表达式或聚集函数。</p><p>对于组合查询的排序（order by）只能出现在最后一句的末尾。  </p><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>INSERT可以插入：  </p><ul><li>插入完整的行  </li><li>插入行的一部分  </li><li>插入某些查询的结果  </li></ul><p>insert插入的值不能和已经存在的值的主键的值重复。</p><p>插入完整的行：  </p><blockquote><p>insert into customers<br>values(‘1000006’,’’Toy Land’,’123 any street’,’new york’,’NY’,’11111’,’USA’,NULL,NULL);  </p></blockquote><p>上述语句存在安全性问题：语句高度依赖插入的顺序，更为安全的方法是：  </p><blockquote><p>insert into customers(cust_id,<br>cust_name,<br>cust_address,<br>cust_city,<br>cust_state,<br>cust_zip,<br>cust_country,<br>cust_contact,<br>cust_email)<br>values(‘….’,’..’,….);     </p></blockquote><p>插入部分行：  </p><blockquote><p>insert into customers(cust_id,<br>cust_name)<br>values(‘’,’’);  </p></blockquote><p>需要注意的是没有插入的行必须支持null或存在默认值。  </p><p>插入检索出的数据：<br>insert select 插入搜索出来的值：    </p><blockquote><p>INSERT into customers(cust_id,cust_contact……)<br>select cust_id,cust_contact,cust_email…from custnew; </p></blockquote><p>此处select出的列不一定需要与插入的列一一对应。<br>一般的INSERT语句只插入一行数据，但insert select则是搜寻出来多少项就插入多少。  </p><p>从一个表复制到另一个表：<br>有一种不使用insert语句的数据插入。select into。<br>与insert select增补数据到一个已经存在的表不同，select into将复制数据到一个新表。  </p><blockquote><p>select *into custCopy from customers;    </p></blockquote><p>此处复制的是所有的内容，如果只是想复制单独的几列可以一一列举。<br>mysql语句：  </p><blockquote><p>create Table Custcopy as select *from customers;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2020/02/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>引爆炸弹：<br><a href="https://res.jisuanke.com/img/upload/20170327/5dba781484cd6db80572f3bd5fe136b93e3b2e60.png" data-fancybox="group" data-caption="alt photo" class="fancybox"><img alt="alt photo" title="alt photo" data-src="https://res.jisuanke.com/img/upload/20170327/5dba781484cd6db80572f3bd5fe136b93e3b2e60.png" class="lazyload"></a>  </p><p>题目描述：<br>在一个$n \times n $的方格地图上，某些方格上放置着炸弹。手动引爆一个炸弹以后，炸弹会把炸弹所在的行和列上的所有炸弹引爆，被引爆的炸弹又能引爆其他炸弹，这样连锁下去。  </p><p>现在为了引爆地图上的所有炸弹，需要手动引爆其中一些炸弹，为了把危险程度降到最低，请算出最少手动引爆多少个炸弹可以把地图上的所有炸弹引爆。</p><p>输入格式<br>第一行输两个整数 n,m，用空格隔开。</p><p>接下来 n 行，每行输入一个长度为 m 的字符串，表示地图信息。0表示没有炸弹，1表示炸弹。</p><p>数据约定：</p><p>对于 60%60% 的数据：1 \le n, m \le 1001≤n,m≤100；</p><p>对于 100%100% 的数据：1 \le n, m \le 10001≤n,m≤1000；</p><p>数据量比较大，不建议用cin输入。</p><p>输出格式<br>输出一个整数，表示最少需要手动引爆的炸弹数。  </p><p>此题为并查集，进行归一化处理，将行数与列数看做一种数，所有的炸弹只要行数或列数有一个相同就会归为一个集合，只有行数、列数都不同的炸弹才属于新的集合。只需遍历所有炸弹位置，统计有多少炸弹集合。  </p><p>样例输入：<br>5   5<br>00010  </p><p>00010  </p><p>01001  </p><p>10001  </p><p>01000  </p><p>输出：2</p><p>代码：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">10010</span>][<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10010</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=x;</span><br><span class="line">    <span class="keyword">while</span>(x!=pre[x])</span><br><span class="line">    &#123;</span><br><span class="line">        x=pre[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a!=pre[a])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> z=a;</span><br><span class="line">        a=pre[a];</span><br><span class="line">        pre[z]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Fa=<span class="built_in">find</span>(a);</span><br><span class="line">    <span class="keyword">int</span> Fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(Fa!=Fb)</span><br><span class="line">    pre[Fa]=Fb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,<span class="built_in">map</span>[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                Union(i,j+n);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;pre[i]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">int</span> a=<span class="built_in">find</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(!vis[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[a]=<span class="literal">true</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>POJ 1182食物链<br>题目：<br>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。  </p><p>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。  </p><p>有人用两种说法对这N个动物所构成的食物链关系进行描述：  </p><p>第一种说法是”1 X Y”，表示X和Y是同类。  </p><p>第二种说法是”2 X Y”，表示X吃Y。  </p><p>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。   </p><p>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。   </p><p>输入：<br>100 7</p><p>1 101 1 </p><p>2 1 2</p><p>2 2 3 </p><p>2 3 3 </p><p>1 1 3 </p><p>2 3 1 </p><p>1 5 5</p><p>输出：<br>3</p><p>此题需明白的点为如果现在的说法与之前矛盾则为假话，因而将一开始最初说的话进行Union，然后每次添加新的情况时都要先进行判断，再进行添加。  </p><p>代码：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">150014</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finda</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=a;</span><br><span class="line">    <span class="keyword">while</span>(pre[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        x=pre[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> finda(n)==finda(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> f1=finda(x);</span><br><span class="line">      <span class="keyword">int</span> f2=finda(y);</span><br><span class="line">      <span class="keyword">if</span>(f1!=f2)</span><br><span class="line">       pre[f1]=f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">3</span>;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100005</span>],b[<span class="number">100005</span>],c[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">        <span class="keyword">int</span> x=b[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> y=c[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(same(x,y+n)||same(x,y+<span class="number">2</span>*n))</span><br><span class="line">                num++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                merge(x,y);</span><br><span class="line">                merge(x+n,y+n);</span><br><span class="line">                merge(x+<span class="number">2</span>*n,y+<span class="number">2</span>*n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(same(x,y)||same(x,y+<span class="number">2</span>*n))</span><br><span class="line">                num++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                merge(x,y+n);</span><br><span class="line">                merge(x+n,y+<span class="number">2</span>*n);</span><br><span class="line">                merge(x+<span class="number">2</span>*n,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java方法参数</title>
      <link href="/2020/02/21/java%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0/"/>
      <url>/2020/02/21/java%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="java方法参数"><a href="#java方法参数" class="headerlink" title="java方法参数"></a>java方法参数</h1><p>程序设计语言中有关将参数传递给函数的方法有两种，一种是按值调用而另一种是按引用调用。<br>以c++作例子来说。  </p><ul><li><p>值调用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>引用调用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以上两种例子分别代表了大多数语言的参数传递方式，但对于java语言来说，尽管有一部分人认为java也存在引用传递，但通过具体事例来看java只存在值传递一种传递方式。  </p></li></ul><p>现定义一函数：   </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">3</span>*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行调用。</span></span><br><span class="line"><span class="keyword">double</span> percent=<span class="number">10</span>;</span><br><span class="line">tripleValue(percemt);</span><br></pre></td></tr></table></figure></div><p>在上述函数执行之后percent并没有变为原先的二倍，函数的具体过程如下：  </p><ol><li>x被初始化为percent值的一个拷贝。  </li><li>x被乘以3后等于30.但percent仍为10；</li><li>方法结束后局部变量x被丢弃。    </li></ol><p>即等价于：percent=10;x=10;x的变化并不会影响percent值的变化。  </p><p>一个方法不可能修改一个基本数据类型的参数，但作为对象的引用的参数结果就截然不同了。<br>定义了一个Employee类，类中有一薪金提高操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    salary=salary*(<span class="number">1</span>+x/<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>若要使职工新进提高两倍可使用如下方法：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span><span class="params">(Employee x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当调用：</p><blockquote><p>harry=new Employee(…..);<br>tripleSalary(harry);  </p></blockquote><p>即如图所示：<br><a href="https://s2.ax1x.com/2020/03/01/32wYGj.png" data-fancybox="group" data-caption="alt photo" class="fancybox"><img alt="alt photo" title="alt photo" data-src="https://s2.ax1x.com/2020/03/01/32wYGj.png" class="lazyload"></a></p><p>具体执行过程为：</p><ol><li>x被初始化为harry值的拷贝，此处为对象的引用  </li><li>raiseSalary方法应用于对象引用时，x和harry同时引用了Employee对象的薪金函数，从而致使salary最终变为3倍。  </li><li>方法结束后，x倍销毁，但harry的引用会使salary一直保持3倍的状态。  </li></ol><p>即等价于：Employee x=harry;x.raiseSalary(200)==harry.raiseSalary(200);<br>当x调用了raiseSalary方法，其由于harry同样引用了Employee里的raiseSalary方法，因而他们都会发生变化。通俗来说是Employee内的东西发生了改变，致使所有引用它的对象都发生了改变。</p><p>使用swap函数仍然可以证明java使用引用传递：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">Swap</span><span class="params">(Employee A,Employee B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee tmp=A;</span><br><span class="line">    A=B;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用：</span></span><br><span class="line">Employee x=<span class="keyword">new</span> Employee(...);</span><br><span class="line">Employee y=<span class="keyword">new</span> Employee(...);</span><br><span class="line">Swap(x,y);</span><br></pre></td></tr></table></figure></div><p>结果对象x与对象y并没有发生变化。  </p><p>其示意图如下：<br><a href="https://s2.ax1x.com/2020/03/01/32wJiQ.png" data-fancybox="group" data-caption="alt photo" class="fancybox"><img alt="alt photo" title="alt photo" data-src="https://s2.ax1x.com/2020/03/01/32wJiQ.png" class="lazyload"></a>  </p><p>其原理即如图所示，通过图示可以看出swap函数改变的仅仅是A和B向Employee指向的线，不论他们如何变化，都始终影响不到对象x和y。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java：文件输入输出</title>
      <link href="/2020/02/19/java%EF%BC%9A%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2020/02/19/java%EF%BC%9A%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="java的文件输入输出"><a href="#java的文件输入输出" class="headerlink" title="java的文件输入输出"></a>java的文件输入输出</h1><h2 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h2><p>在java中要想对文件进行读取则需要使用File对象构造一个Scanner对象：<br><code>Scanner in=new Scanner(Paths.get(&quot;文件名/文件位置&quot;)，&quot;字符编码形式&quot;);</code><br>在文件读取时既可以在相对位置创建文本文件后，使用文件名进行读取，也可以直接使用文件绝对位置进行读取：</p><ol><li><p>使用文件名：<br>当指定一个相对的文件名时，例如”myfile.txt”，文件会位于Java虚拟机启动路径的相对位置（一般位于该java project的同层目录）。可以使用：<br><code>String dir =System.getProperty(&quot;user.dir&quot;);</code><br>文件读取：<br><code>Scanner in=new Scanner(Paths.get(&quot;myfile.txt&quot;)，&quot;UTF-8&quot;);</code>  </p></li><li><p>使用绝对路径：<br><code>Scanner in=new Scanner(Paths.get(&quot;D://Java//Projects//myfile.txt&quot;)，&quot;UTF-8&quot;);</code><br>值得注意的是如果文件名含有反斜杠符号，需要在反斜杠符号之前再添加一个反斜杠。  </p></li></ol><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>要想写入文件则需要构造一个PrintWriter对象：<br><code>PrintWriter out=new PrintWriter(&quot;文件名&quot;，&quot;字符编码&quot;);</code>  </p><p>对于文件明的处理与文件输入时一样。  除此之外在构造完成并进行输出操作之后，还需要对缓存区进行清理并关闭读写流，因而需要使用：<br><code>out.flus()</code>，以及<code>out.close</code> 。如果不使用out.flus则文件不会输出成功，因为数据还会留存在缓冲区里，不会输出在文件中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一下是将数据从一个文件读入并输出到另一个文件的代码：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Scanner in =<span class="keyword">new</span> Scanner(Paths.get(<span class="string">"pw.txt"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">       PrintWriter out=<span class="keyword">new</span> PrintWriter(<span class="string">"1.txt"</span>,<span class="string">"UTF-8"</span>);</span><br><span class="line">       out.print(in.next());</span><br><span class="line">       out.flush();</span><br><span class="line">       out.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 文件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex公式总结</title>
      <link href="/2020/02/13/latex%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/13/latex%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在博客撰写的过程中不免会遇到各种数理公式的使用，因而当撰写markdown文档时如需添加数学公式，可以使用两个美元符号$$包裹TeX或LaTeX格式的数学公式来实现，当提交之后，文章页会调用Mathjax对数学公式进行渲染。  </p><h1 id="公式的具体实现"><a href="#公式的具体实现" class="headerlink" title="公式的具体实现"></a>公式的具体实现</h1><p>在行中的公式可以采用单$表示：  </p><blockquote><p><code>$</code> 数学公式 <code>$</code>   </p></blockquote><p>独立公式则采用双$表示：   </p><blockquote><p><code>$$</code> 数学公式 <code>$$</code></p></blockquote><h2 id="声调以及变音符号"><a href="#声调以及变音符号" class="headerlink" title="声调以及变音符号"></a>声调以及变音符号</h2><blockquote><p>\dot{a}(<code>一点a</code>), \ddot{a}（<code>两点a</code>）, \acute{a}（<code>第二声</code>）, \grave{a}（<code>第四声</code>）  </p></blockquote><p>$\dot{a}, \ddot{a}, \acute{a}, \grave{a} $  </p><blockquote><p>\check{a}（<code>第三声</code>）, \breve{a}, \tilde{a}, \bar{a}（<code>第一声</code>）  </p></blockquote><p>$ \check{a}, \breve{a}, \tilde{a}, \bar{a} $  </p><blockquote><p>\hat{a}, \widehat{a}, \vec{a}（<code>向量</code>）  </p></blockquote><p>$ \hat{a}, \widehat{a}, \vec{a} $  </p><h2 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h2><p>指数：  </p><blockquote><p>exp_a b =a^b,    \exp b =e^b,    10^m  </p></blockquote><p>$exp_a b= a^b, \exp b =e^b, 10^m $  </p><p>对数：  </p><blockquote><p>\ln c,    \lg d = \log e,    \log_{<code>底数</code>} <code>指数</code>   </p></blockquote><p>$\ln c, \lg d= \log e, \log_{2} 3 $  </p><p>三角函数：  </p><blockquote><p>\sin a, \cos b, \tan c, \cot d, \sec e, \csc f, \arcsin a, \arccos b, \arctan c, \arccot d  </p></blockquote><p>$\sin a, \cos b, \tan c, \cot d, \sec e, \csc f, \arcsin a, \arccos b, \arctan c, arccot d$  </p><h2 id="符号函数，绝对值："><a href="#符号函数，绝对值：" class="headerlink" title="符号函数，绝对值："></a>符号函数，绝对值：</h2><blockquote><p>\sgn r, \left\vert s \right\vert  </p></blockquote><p>$\left\vert s \right\vert$  </p><h2 id="最值和极限："><a href="#最值和极限：" class="headerlink" title="最值和极限："></a>最值和极限：</h2><blockquote><p>\min(x,y) ,\max(x,y)  </p></blockquote><p>$\min(x,y) ,\max(x,y)$  </p><blockquote><p>\min x, \min y, \inf s, \sup t  </p></blockquote><p>$\min x, \min y, \inf s, \sup t$  </p><blockquote><p>\lim u，  lim_{x \to  \infty} \frac{1}{n(n+1)}  </p></blockquote><p>$\lim u,    \lim_{x \to   \infty} \frac{1}{n(n+1)}$  </p><h2 id="微积分及导数"><a href="#微积分及导数" class="headerlink" title="微积分及导数"></a>微积分及导数</h2><blockquote><p>dt  ,\mathrm{d}t,  \partial t,  \nabla\psi  </p></blockquote><p>$dt,  \mathrm{d}t,  \partial t,  \nabla\psi$   </p><blockquote><p>dy/dx,  \mathrm{d}y/\mathrm{d}x,  \frac{\mathrm{d}y}{\mathrm{d}x},  \frac{\partial^2}{\partial x_1\partial x_2}y  </p></blockquote><blockquote><p>\prime, \backprime, f^\prime, f’, f’’, f^{(3)}, \dot y, \ddot y  </p></blockquote><p>$\prime,  \backprime, f^\prime, f’, f’’ ,f^{(3)}, \dot y, \ddot y$  </p><blockquote><p>\infty<br>$\infty$   </p></blockquote><h2 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h2><blockquote><p>\surd,  \sqrt{2},  \sqrt[n]{},  \sqrt[3]{\frac{x^3+y^3}{2}}  </p></blockquote><p>$\surd,   \sqrt{2},   \sqrt[n]{2},  \sqrt[3]{\frac{x^3+y^3}{2}}$  </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote><p>+, -, \pm, \mp, \dotplus   </p></blockquote><p>$+ , - , \pm, \mp, \dotplus$  </p><blockquote><p>\times,  \div, \divideontimes, /, \backslash   </p></blockquote><p>$\times , \div, \divideontimes, / , \backslash$  </p><blockquote><p>\oplus, \ominus, \otimes, \oslash, \odot</p></blockquote><p>$\oplus, \ominus, \otimes, \oslash, \odot$</p><blockquote><p>\bigoplus,  \bigotimes, \bigodot  </p></blockquote><p>$\bigoplus, \bigotimes, \bigodot$  </p><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><blockquote><p>s_k \equiv 0 \pmod{m}  </p></blockquote><p>$s_k \equiv 0 \pmod{m}$  </p><blockquote><p>a \bmod b  </p></blockquote><p>$a \bmod b$  </p><blockquote><p>\gcd(m,n), \operatorname{lcm}(m,n)  </p></blockquote><p>$\gcd(m,n), \operatorname{lcm}(m,n)$  </p><blockquote><p>\mid, \nmid, \shortmid, \nshortmid</p></blockquote><p>$\mid, \nmid, \shortmid, \nshortmid$  </p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote><p>\emptyset, \varnothing  </p></blockquote><p>$\emptyset, \varnothing$  </p><blockquote><p>\in, \notin  \not\in, \ni, \not\ni  </p></blockquote><p>$\in, \notin  \not\in,\ni,\not\ni$  </p><blockquote><p>\cap, \Cap, \sqcap, \bigcap</p></blockquote><p>$\cap, \Cap, \sqcap, \bigcap$</p><blockquote><p>\cup, \Cup, \sqcup, \bigcup </p></blockquote><p>$\cup, \Cup, \sqcup, \bigcup$</p><blockquote><p>\setminus ,\times  </p></blockquote><p>$\setminus ,\times$  </p><blockquote><p>\subset, \Subset, \sqsubset </p></blockquote><p>$\subset, \Subset, \sqsubset$</p><blockquote><p>\supset, \Supset, \sqsupset</p></blockquote><p>$\supset, \Supset, \sqsupset$</p><blockquote><p>\subseteq, \nsubseteq</p></blockquote><p>$\subseteq, \nsubseteq$  </p><blockquote><p>\supseteq, \nsupseteq </p></blockquote><p>$\supseteq, \nsupseteq$</p><blockquote><p>\subseteqq, \nsubseteqq </p></blockquote><p>$\subseteqq, \nsubseteqq$  </p><blockquote><p>\supseteqq, \nsupseteqq  </p></blockquote><p>$\supseteqq, \nsupseteqq$ </p><h2 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h2><blockquote><p>=, \ne, \neq, \equiv, \not\equiv  </p></blockquote><p>$=, \ne, \neq, \equiv, \not\equiv$  </p><blockquote><p>\doteq, \doteqdot  </p></blockquote><p>$\doteq, \doteqdot$  </p><blockquote><p>\sim, \nsim, \backsim, \thicksim, \simeq, \backsimeq, \eqsim, \cong, \ncong  </p></blockquote><p>$\sim, \nsim, \backsim, \thicksim, \simeq, \backsimeq, \eqsim, \cong, \ncong$  </p><blockquote><p>\approx, \thickqpprox, \approxeq, \propto, \varpropto  </p></blockquote><p>$\approx, \thickapprox, \approxeq, \propto, \varpropto$  </p><blockquote><p>&lt;, \nless, \ll, \not\ll, \lll, \not\lll,\lessdot  </p></blockquote><p>$&lt;, \nless, \ll, \not\ll, \lll, \not\lll,\lessdot$  </p><blockquote><p>/&gt;, \ngte, \gg, \not\gg, \ggg, \not\ggg, \gtrdot  </p></blockquote><p>$&gt;, \ngtr, \gg, \not\gg, \ggg, \not\ggg, \gtrdot$</p><blockquote><p>\le, \leq, \lneq, \leqq  </p></blockquote><p>$\le, \leq, \lneq, \leqq$  </p><blockquote><p>\ge, \geq, \gneq, \geqq  </p></blockquote><p>$\ge, \geq, \gneq, \geqq$  </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>康托展开</title>
      <link href="/2020/02/10/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2020/02/10/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><h2 id="定义即公式"><a href="#定义即公式" class="headerlink" title="定义即公式"></a>定义即公式</h2><p>康托展开表示的是全排列到自然数的映射，康托展开的本质即为某一全排列在整个全排列序列中的顺序。即<code>1 3 2</code>在由<code>1,2,3</code>三个数组成的全排列中的顺序为2。同时此项展开是一个可逆的过程，存在正向运算以及逆向运算。公式为：  </p><blockquote><p>X= a[n] * (n-1)! + a[n-1]*(n-2)!+ … +a[i] * (i-1)! + … + a[1] * 0!   </p></blockquote><p>其中a[i]为整数，并且 0&lt;= a[i]  &lt; i, 1&lt;= i &lt;=n.<br>a[i]:设x为一串数字或字符串中第i个元素，a[i]即表示x之后的元素中比x小的元素的个数。<br>例如序列： 3 2 1<br>X=2 * 2！+1 * 1!+ 0 * 0!=5;  </p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>由康托展开的公式可知：n位（0~n-1）全排列后，其康托展开唯一且最大约为n!，因此可以由更小的空间来储存这些排列。由公式可将X逆推出对应的全排列。因此康托展开多用于构建哈希表时的空间压缩。  </p><h2 id="例题代码"><a href="#例题代码" class="headerlink" title="例题代码"></a>例题代码</h2><p>现在有”abcdefghijkl”12个字符，将其所有的排列中按字典序排列，给出任意一种排列，说出这个排列在所有的排列中是第几小的？<br>  <strong><em>输入</em></strong> ： </p><p>每行输入一行字符串，保证是a~l这12个字符的某种排列<br>EOF结束</p><p><strong><em>输出</em></strong>：  </p><p>输出一个整数，代表这个排列排在第几位。<br>样例输入：<br>abcdefghijkl<br>abcdefghiklj<br>gfkedhjblcia  </p><p>样例输出1：<br>0<br>3<br>260726925  </p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||i==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i*factorial(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[j]&lt;s[i])</span><br><span class="line">&#123;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans+=factorial(s.<span class="built_in">size</span>()-i<span class="number">-1</span>)*tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>逆康托公式：即给出序号，输出排列：<br>代码：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span> || k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> k * factor(k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">105</span>], book[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k, m, key, x, j;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line"><span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span> book);</span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=m;++i)&#123;</span><br><span class="line">k = factor(m-i);</span><br><span class="line">key = n/k+<span class="number">1</span>;</span><br><span class="line">n %= k;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(key)&#123;</span><br><span class="line"><span class="keyword">if</span>(!book[j]) --key;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">ans[i] = j<span class="number">-1</span>;</span><br><span class="line">book[j<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 康托展开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitset的用法（十进制转二进制）</title>
      <link href="/2020/02/04/bitset%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2020/02/04/bitset%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="bitset的用法（十进制转二进制）"><a href="#bitset的用法（十进制转二进制）" class="headerlink" title="bitset的用法（十进制转二进制）"></a>bitset的用法（十进制转二进制）</h1><p>C++的bitset存在于<code>&lt;bitset&gt;</code>的头文件中，是一种类似于数组的结构，它的每一个元素只能是0或1，因而多用于十进制到二进制的转化类问题的解决。bitset的基本格式为:  </p><blockquote><p>bitset&lt;保留的位数&gt; b(要求的十进制数)  </p></blockquote><p>bitset常见构造：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;2&gt; b(<span class="number">11</span>);<span class="comment">//11的二进制1011，保留后两位为为11；</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;5&gt; b(<span class="number">11</span>);<span class="comment">//5位超过4位，所以添加0，为01011；  </span></span><br><span class="line">b.to_string();<span class="comment">//将其转化为字符串类型；</span></span><br></pre></td></tr></table></figure></div><h2 id="在例题中的使用："><a href="#在例题中的使用：" class="headerlink" title="在例题中的使用："></a>在例题中的使用：</h2><h3 id="蓝桥杯明码："><a href="#蓝桥杯明码：" class="headerlink" title="蓝桥杯明码："></a>蓝桥杯明码：</h3><p>标题：明码  </p><p>汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。<br>16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。  </p><p>一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。<br>把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，<br>一共16行，布局是：  </p><p>第1字节，第2字节  </p><p>第3字节，第4字节  </p><p>….  </p><p>第31字节, 第32字节  </p><p>1  </p><p>2  </p><p>3  </p><p>4  </p><p>这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。<br>题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。  </p><p>这段信息是（一共10个汉字）：  </p><p>4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0  </p><p>16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16  </p><p>4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0  </p><p>0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4  </p><p>4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64  </p><p>16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128  </p><p>0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0  </p><p>2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0  </p><p>1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0  </p><p>0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0<br>用上述的库函数可以很简单的解决：<br>代码：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">bitset</span>&lt;8&gt; b(n);</span><br><span class="line">   s=b.to_string();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">bitset</span>&lt;8&gt; q(m);</span><br><span class="line">   s=q.to_string();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>结果显示为：   </p><p><a href="http://q4wxf2l6s.bkt.clouddn.com/20180402083607793.png" data-fancybox="group" data-caption="RUNOOB tu" class="fancybox"><img alt="RUNOOB tu" title="RUNOOB tu" data-src="http://q4wxf2l6s.bkt.clouddn.com/20180402083607793.png" class="lazyload"></a>    </p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 二进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp背包问题</title>
      <link href="/2020/01/31/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/31/dp%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><ul><li>问题描述：<br>有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？<code>(对于每个物品不可以取多次，最多只能取一次，之所以叫做0-1背包，0表示不取，1表示取)</code><br>此题的每个物品的数量是有限的，对于每个物体只有两种可能，要么不取，要么取。  </li><li>状态转移方程为：<blockquote><p>dp[i+1][j]=dp[i][j] ( j &lt; w[i] ); //即第i个物品的重量太大，不选<br>dp[i+1][j]=max(dp[i][j-w[i]]+v[i],dp[i][j])( 其他 ) //即第i个物品满足，可以选择，也可以不选择；  </p></blockquote></li></ul><p>其中<code>dp[i+1][j]</code>表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，且<code>dp[0][j]=0</code>。  </p><ul><li>代码：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> W;</span><br><span class="line"><span class="keyword">int</span> w[MAXN],v[MAXN];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)</span><br><span class="line">&#123;</span><br><span class="line">dp[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j]=dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[i][j],dp[i][j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;W;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>此时的时间复杂度为: <strong><em>O（nW）</em></strong>;<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2>完全背包问题与0-1背包问题的区别在于完全背包的每个物品的数量为固定数量，因而转移状态方程发生了变化：<blockquote><p>dp[i+1][j]=max{dp[i-k<em>w[i]]+k</em>v[i] | 0&lt;=k}<br>dp[0][j]=0;  </p></blockquote></li></ul><p>其中<code>dp[i+1][j]表示从前i种物品中挑选总重量不超过j时总价值的最大值</code>。<br>代码:  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 101</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> W;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*w[i]&lt;=j;k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j-k*w[i]]+k*v[i]);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;W;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>此时形成了一个三重循环，时间复杂度为<strong><em>O(nW^2)</em></strong>,显然不够好，从状态转移方程以及方程意义来看，其中在dp[i+1][j]的计算中选择k(k&gt;=1)的情况，与在dp[i+1][j-w[i]]的计算结果中选择k-1个的情况是一样的，这就造成了大量的重复计算，对状态转移方程进行化简：</p><blockquote><p>&#160;&#160;&#160;max{dp[i][j-k<em>w[i]]+k</em>v[i]|0&lt;=k}<br>= max(dp[i][j],max(dp[i][j-k<em>w[i]]+k</em>v[i]|k&gt;=1))<br>= max(dp[i][j],max{dp[i][j-w[i]-k<em>w[i]]+k</em>v[i]|k&gt;=0}+v[i]<br>= max(dp[i][j],dp[i+1][j-w[i]]+v[i])  </p></blockquote><p>根据化简结果可得优化后的代码为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 101</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ap[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> W;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j]=dp[i][j]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j]=<span class="built_in">max</span>(dp[i][j],dp[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;W;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>此时的时间复杂度与0-1背包相同为：<strong><em>O (nW)</em></strong>  </p><h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p>对于上述的两个问题<strong><em>O (nW)</em></strong>的时间复杂度已经是最优化的状态了，但代码的空间复杂度还可以进行优化。观察上述代码可以将表示状态转移方程的二维数组化为一位，代码如下：<br>0-1背包问题：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> W;</span><br><span class="line"><span class="keyword">int</span> w[MAXN],v[MAXN];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=W;j&gt;=w[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>完全背包问题：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> W;</span><br><span class="line"><span class="keyword">int</span> w[MAXN],v[MAXN];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=W;j++)</span><br><span class="line">&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由上面的两个代码比较可知一维数组的0-1和完全背包问题的区别仅在于循环的方向，那么为什么0-1背包的方向为逆序而完全背包为正序呢？原因还是在于状态转换方程。对于0-1背包问题来说：<code>dp[i+1][j]=dp[i][j] or dp[i][j-w[i]+v[i]</code>,现状态由且仅由上一个状态的转换方程决定，因而j从W开始，此时的<code>dp[j-w[i]]+v[i]</code>所代表的值由于j是从大到小的顺序，j的每一个取值的结果都是由上一个状态的值推出，但对于完全背包问题：<code>dp[i+1][j]=max(dp[i][j],dp[i+1][j-w[i]]+v[i])</code>,其结果是由当前状态推出。因而j的取值需要从小到大进行，有本次状态转移方程的值推出后续的本次状态转移方程的值，因而会存在逆序的差异。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git相关操作</title>
      <link href="/2020/01/29/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/01/29/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><h2 id="创建-Git仓库："><a href="#创建-Git仓库：" class="headerlink" title="创建 Git仓库："></a>创建 Git仓库：</h2><h3 id="在当前目录新建一个Git代码库"><a href="#在当前目录新建一个Git代码库" class="headerlink" title="在当前目录新建一个Git代码库"></a>在当前目录新建一个Git代码库</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></div><h3 id="新建一个目录，将其初始化为Git代码库"><a href="#新建一个目录，将其初始化为Git代码库" class="headerlink" title="新建一个目录，将其初始化为Git代码库"></a>新建一个目录，将其初始化为Git代码库</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git init [project-name]</span><br></pre></td></tr></table></figure></div><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>将文件添加到仓库分为两步：<code>add</code>和<code>commit</code>,其中commit部分可以添加适当的说明文字，以便版本回溯时参考使用。 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add filename</span><br><span class="line">$ git commit-m&quot;discribtion words&quot;</span><br></pre></td></tr></table></figure></div><p>此外可以add多个文件后再统一commit，也可以add一次，commit一次。  </p><h2 id="状态以及过程"><a href="#状态以及过程" class="headerlink" title="状态以及过程"></a>状态以及过程</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>可以运行<code>git status</code>命令查看git的提交状态，此外当对文件进行修改之后，还未<code>commit</code>的时候可以使用<code>git diff</code>查看具体修改了什么。   </p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure></div><p>顾名思义log有航海日记得意思，<code>git log</code>命令是显示最近到最远的提交日志，但这个命令得到的消息较为繁琐。<br>添加’–pretty=oneline’参数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty&#x3D;online</span><br></pre></td></tr></table></figure></div><p>则将日志信息精简为只有<code>commit id（版本号）</code>的样式。  </p><h2 id="版本回溯"><a href="#版本回溯" class="headerlink" title="版本回溯"></a>版本回溯</h2><p>当出现错误，或想要回到修改提交过的版本时只需要<code>git reset</code>命令即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$git reset --hard HEAD</span><br><span class="line">$git reset --hard HEAD^</span><br></pre></td></tr></table></figure></div><p>第一个指令是回溯到上一个版本，加上一个<code>^</code>则是再向前回溯一个版本，依次类推，加上几个 <code>^</code> 符号就是再次向前回退几个版本。当然这种命令存在一定的局限性，因为命令的格式随着回推的进行变得越来越繁琐，因而在上一条介绍中提到的<strong>版本号</strong>就派上了用场：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit id</span><br></pre></td></tr></table></figure></div><p>版本号无需写全，只需写入前4,5位即可。<br>此外除了<code>git log</code>可以查到版本号，使用指令<code>git reflog</code>可以更好更直观的找到之前的版本号，以便进行回溯。</p><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><h2 id="提交前"><a href="#提交前" class="headerlink" title="提交前"></a>提交前</h2><p>当尽行修改或是删除之后，过还没有进行提交，则可以使用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout filename</span><br></pre></td></tr></table></figure></div><p>进行撤销操作，可以丢弃掉工作区的修改，使其恢复修改前的状态。  </p><h2 id="提交后"><a href="#提交后" class="headerlink" title="提交后"></a>提交后</h2><p>当你已经提交，即已经<code>git add</code>但还没有<code>git commit</code>之时，则需：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD filename</span><br></pre></td></tr></table></figure></div><p>可以将暂存区的修改撤销，重新放回工作区。  </p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除操作只有两步，将工作区的文件删去，将版本库中的文件删去。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm filename  </span><br><span class="line">$ git rm filename  </span><br><span class="line">$ git commit -m &quot;discribtions&quot;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/01/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/01/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="我的一篇博文-markdown编写规则"><a href="#我的一篇博文-markdown编写规则" class="headerlink" title="我的一篇博文(markdown编写规则)"></a>我的一篇博文(markdown编写规则)</h1><h2 id="My-first-blog"><a href="#My-first-blog" class="headerlink" title="My first blog."></a>My first blog.</h2><h3 id="This-is-my-first-article-in-my-blog"><a href="#This-is-my-first-article-in-my-blog" class="headerlink" title="This is my first article in my blog!"></a>This is my first article in my blog!</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">666</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"it's gonna to be successful!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>在markdown文档中使用”#”来区分标题，一个”#”表示一级标题，两个”#”表示二级标题，以此类推；<br>例子如下：  </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>对于markdown文档来说，段落的换行需要两个空格加上一个回车，当然也可以在段落的后面使用一个空行来表示重新开始一个段落。  </p><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>markdown文档常用的有六种字体表示方法如下：  </p><p><code>*斜体文本*</code><br><code>**粗体文本**</code><br><code>***粗斜体文本***</code>  </p><p>效果如下：<br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong>      </p><h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><p>你可以在一行中用三个以上的星号、减号来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格（<strong><em>减号必须插入空格</em></strong>）。下面每种写法都可以建立分隔线：表示方法方法如下：<br><code>***</code> 或 <code>* * *</code> 或 <code>- - -</code><br>效果如下：  </p><hr><hr><hr><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <del>~ 即可，实例如下：<br>`</del>jackeylove<del>`<br>效果如下：<br>~</del>jackeylove~~    </p><h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p><code>通过html中的&lt;u&gt;实现</code>，效果如下：<br><u>The Big Bang Theory</u>    </p><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>脚注是对文本的补充说明，markdown文档的脚注格式为<code>[^要注明的文本]</code><br>效果如下：<br>创建脚注格式类似这样 <a href="薄雾浓云愁永昼，瑞脑消金兽">^RUNOOB</a>。</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>markdown支持有序以及无序列表。</p><h2 id="列表标记"><a href="#列表标记" class="headerlink" title="列表标记"></a>列表标记</h2><p>无序列表使用星号，加号或减号作为列表标记：<br><code>* 第一项</code><br><code>+ 第二项</code><br><code>- 第三项</code><br>效果图如下：  </p><ul><li>第一项  </li></ul><ul><li>第二项  </li></ul><ul><li>第三项     </li></ul><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项添加四个空格即可：<br>如：<code>[space][space][space][space]-嵌套</code><br>效果图为: </p><ol><li>第一项：    <ul><li>第一项嵌套的第一个元素  </li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素  <h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1>markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟着一个空格符号。当想要结束区块引用时只需输入两个换行符即可结束区块引用。<br>即：<br><code>&gt; 区块引用</code><br>效果图如下：<blockquote><p>区块引用  </p></blockquote></li></ul></li></ol><p>此外区块还可以进行嵌套，一个&gt;符号是最外层，两个&gt;是第一层嵌套，以此类推：  </p><blockquote><p>最外层  </p><blockquote><p>第二层  </p><blockquote><p>第三层  </p></blockquote></blockquote></blockquote><p>区块中使用列表实例如下：<br><code>&gt;区块中使用列表</code><br><code>&gt;1. 第一项</code><br><code>&gt;2. 第二项</code><br><code>&gt;+ 第一项</code><br><code>&gt;+ 第二项</code><br>效果为：  </p><blockquote><p>区块中使用列表</p><ol><li>第一项  </li></ol><ul><li>第一项  </li><li>第二项</li></ul><ol start="2"><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>列表中使用区块则需要在&gt;前添加四个空格的缩进。<br>实例如下：<br><code>*第一项</code><br>    <code>&gt;tbbt</code><br>    <code>&gt;lol</code><br><code>*第二项</code><br>    <code>&gt;pop3</code><br>    <code>&gt;bob2</code><br>效果图如下：  </p><ul><li>第一项  <blockquote><p>tbbt<br>lol</p></blockquote></li><li>第二项    <blockquote><p>pop3<br>bob2    </p></blockquote></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>如果是段落上的一个函数或代码的一个小片段可以用(`)将其包起来。       </p><blockquote><p>如<u><code>printf</code></u>函数  </p></blockquote><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块用<strong><em>四个空格</em></strong>或一个<strong>Tab键</strong>  </p><ul><li>若要使代码高亮则在需要高亮的代码块的前一行及后一行使用三个反引（或~ 键）,<u>注意在代码区块的末尾的三个[<code>*</code>,<code>*</code>,<code>*</code>]后要紧跟着回车</u> </li><li>同时第一行反引号后面，输入代码块所使用的语言，实现代码高亮。  <h3 id="代码一："><a href="#代码一：" class="headerlink" title="代码一："></a>代码一：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">666</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"it's gonna to be successful!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="代码二："><a href="#代码二：" class="headerlink" title="代码二："></a>代码二：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">666</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"it's gonna to be very very successful!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1>链接使用方法如下：  <blockquote><p>[链接名称]（链接地址）<br>或者<br>&lt;链接地址&gt;<br>例如：<br>[Google] (<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>)<br>&lt;<a href="http://www.baidu.com&gt;" target="_blank" rel="noopener">www.baidu.com&gt;</a>  </p></blockquote></li></ul><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>markdown 图片语法格式如下：  </p><blockquote><p><a href="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" data-fancybox="group" data-caption="alt 属性文本" class="fancybox"><img alt="alt 属性文本" title="alt 属性文本" data-src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" class="lazyload"></a><br>![alt<br><a href="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" data-fancybox="group" data-caption="alt 属性文本" class="fancybox"><img alt="alt 属性文本" title="alt 属性文本" data-src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" class="lazyload"></a>  </p></blockquote><ul><li>开头一个感叹号！  </li><li>接着一个方括号，里面放上图片的替代文字    </li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例：  <blockquote><p><a href="http://static.runoob.com/images/runoob-logo.png" data-fancybox="group" data-caption="RUNOOB 图标" class="fancybox"><img alt="RUNOOB 图标" title="RUNOOB 图标" data-src="http://static.runoob.com/images/runoob-logo.png" class="lazyload"></a><br><a href="http://q4wxf2l6s.bkt.clouddn.com/%E6%8D%95%E8%8E%B7.PNG" data-fancybox="group" data-caption="程序 图标" class="fancybox"><img alt="程序 图标" title="程序 图标" data-src="http://q4wxf2l6s.bkt.clouddn.com/%E6%8D%95%E8%8E%B7.PNG" class="lazyload"></a><br><a href="http://static.runoob.com/images/runoob-logo.png" data-fancybox="group" data-caption="RUNOOB 图标" class="fancybox"><img alt="RUNOOB 图标" title="RUNOOB 图标" data-src="http://static.runoob.com/images/runoob-logo.png" class="lazyload"></a></p></blockquote></li></ul><h1 id="结尾语"><a href="#结尾语" class="headerlink" title="结尾语"></a>结尾语</h1><p>对于hexo+git的组合来说，文章通过markdown书写，然后通过hexo g生成静态文件，再部署到服务器上，完成对文章的发布，所以说，markdown在当今html，css大行其道的时候仍能保留有其一席之地。  </p><p>$$<br>\begin{matrix} \lim_{n \to \infty}x_n \end{matrix}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown文档格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/10/hello-world/"/>
      <url>/2020/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
